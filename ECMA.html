<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <div>hello </div>
    <script>
        function fun1() {
            let total = 30;
            let msg = passthru `The total is ${total} (${total*1.05} with tax)`;

            function passthru(args) {
                let i = 0;
                let result = '';
                console.log(args);
                console.log(arguments);
                args = arguments[0];
                while (i < args.length) {
                    console.log(args[i])
                    result += args[i++];
                    if (i < arguments.length) {
                        result += arguments[i];
                        console.log(arguments[i]);
                    }

                }
                return result;
            }
            console.log(msg);
        }

        function fun2() {
            //宏任务和微任务和事件循环机制
            console.log('f');
            setTimeout(() => {
                console.log("5");
            }, 2002);
            for (let i = 0; i < 1000000; i++);
            fun5();
            for (let i = 0; i < 1000000; i++);
            setTimeout(() => {
                console.log("4");
            }, 2001);

            setTimeout(console.log("0"), 3000);

            new Promise((resolve, reject) => {
                console.log('2');
                resolve();
                console.log('22');
            }).then(() => {
                console.log('then');
            })

            setTimeout(() => {
                new Promise((resolve, reject) => {
                    console.log('3');
                    resolve();
                    console.log('33');
                }).then(console.log('then1'))
            }, 0)
        }
        //fun2();

        function fun3() {
            var f = [];
            for (var i = 0; i < 5; i++) {
                function f2() {
                    //利用闭包存储变量 如果k声明在f2以外的作用域的话输出结果为4
                    let k = i;
                    return function () {
                        console.log(k);
                    };
                }
                f[i] = f2();
            }
            f[2]();

            var f2 = [];
            //let 块级作用域
            for (let i = 0; i < 5; i++) {
                f2[i] = function () {
                    console.log(i + '**');
                }
            }
            f2[2]();

        }
        // fun3();

        function fun4() {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    console.log(i + 1);
                })
            }

            for (var i = 0; i < 5; i++) {
                setTimeout((i) => {
                    console.log(i + 1);
                }, 0, i)
            }
        }

        function fun5() {
            async function timeout(ms) {
                await new Promise((resolve) => {
                    setTimeout(resolve, ms);
                }).then(() => {
                    console.log('延迟了50ms')
                })
            }

            async function asyncPrint(value, ms) {
                await timeout(ms);
                console.log(value);
            }
            asyncPrint('hello world', 2002);
        }
        //fun5();

        function fun6() {
            async function f() {
                // 等同于
                // return 123;
                return await 123; //返回的值作为回调函数的参数
            }
            const p = f();
            console.log(p);
            f().then(console.log)
        }
        // fun6();

        function fun7() {
            async function loginOrder(urls) {
                //并发读取远程urls
                const textPromises = urls.map(async url => {
                    const response = await fetch(url);
                    return response.text();
                })
                //按顺序输出
                for (const textPromise of textPromises) {
                    console.log(await textPromise);
                }
            }
            //     上面代码中，虽然map方法的参数是async函数，但它是并发执行的，
            //     因为只有async函数内部是继发执行，外部不受影响。
            //     后面的for..of循环内部使用了await，因此实现了按顺序输出。
        }

        // function fun8() {
        //     const asyncIterable = createAsyncIterable(['a', 'b']);
        //     const asyncIterator = asyncIterable[Symbol.asyncIterable]();
        //     asyncIterator.next().then(asyncResult1 => {
        //         console.log(asyncResult1);
        //         return asyncIterator.next();
        //     }).then(asyncResult2=>{
        //         console.log(asyncResult2);
        //         return asyncIterator.next();
        //     }).then(asyncResult3=>{
        //         console.log(asyncResult3);
        //     })
        // }
        // fun8();
        function fun9() {
            var myTask =
                `onmessage = function (e) {
                    var data = e.data;
                    data.push('hello');
                    console.log('worker:', data); // worker: [1, 2, 3, "hello"]
                    postMessage(data);
                };
            `;

            var blob = new Blob([myTask]);
            var myWorker = new Worker(window.URL.createObjectURL(blob));

            myWorker.onmessage = function (e) {
                console.log(e);
                var data = e.data;
                console.log('page:', data); // page: [1, 2, 3, "hello"]
                console.log('arr:', arr); // arr: [1, 2, 3]
            };

            let arr = [1, 2, 3];
            myWorker.postMessage(arr);
        }
        //fun9();
    </script>

    <script>
        //Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。
        //Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。
        class Foo {
            constructor(...args) {
                    this.args = args;
                }
                *[Symbol.iterator]() {
                    for (let arg of this.args)
                        console.log(arg);
                }
        }
        for (let v of new Foo("helllo", "world!")) {
            console.log(v);
        }

        //this的指向:可能报错TypeError: Cannot read property 'print' of undefined
        class Logger {
            //this绑定
            // constructor(){
            //     this.printName = this.printName.bind(this);
            // }
            //箭头函数
            constructor() {
                this.printName = (name = 'there') => {
                    this.print(`hello${name}`);
                }
            }
            print(text) {
                console.log(text);
            }
        }

        const logger = new Logger();
        const {
            printName
        } = logger;
        printName(' world!');

        const bar = Symbol('bar');
        const snaf = Symbol('snaf');

        class myClass {
            foo(baz) {
                    console.log("here");
                    this[bar](baz);
                }
                [bar](baz) {
                    console.log('there');
                    return this[snaf] = baz;
                }
        }

        var my = new myClass();
        my.foo('darcy');
        var x = Reflect.ownKeys(myClass.prototype);
        console.log(x);


        function Person(name) {
            if (new.target !== undefined) { //new.target === Person
                this.name = name;
                console.log(this.name);
            } else {
                throw new Error('必须使用new生成实例');
            }
        }
        var p = new Person('darcy');
        //var newp = Person.call(p,'colines');//报错
        //Class内部使用new命令，返回当前Class
        class Rectangle {
            constructor(length, width) {
                console.log(new.target === Rectangle);
                this.length = length;
                this.width = width;
            }
        }
        var obj = new Rectangle(3, 4); // 输出 true

        //子类继承父类时，new.target会返回子类。可以用来写出某个类只有继承之后才能使用
        // class Rectangle {
        //     constructor(length, width) {
        //         console.log(new.target === Rectangle);
        //     // ...
        //     }
        // }

        class Square extends Rectangle {
            constructor(length, width) {
                super(length, width);
            }
        }
        var obj = new Square(3, 5); // 输出 false

        //五种遍历方法
        // for...in 遍历对象自身的和继承的可枚举属性
        // Object.keys  遍历对象的可枚举属性
        // Object.getOwnPropertyNames   遍历对象的所有属性 前三种不包括Symbol属性
        // Object.getOwnPropertySymbols  遍历对象的所有Symbol属性
        // Reflect.ownKeys  遍历对象的所有属性，包括是否枚举，Symbol属性
        //全部返回一个数组，遍历对象的键名 遍历的次序规则：
        // 首先遍历所有数值键，按照数值升序排列。
        // 其次遍历所有字符串键，按照加入时间升序排列。
        // 最后遍历所有 Symbol 键，按照加入时间升序排列。
        // Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
        // ['2', '10', 'b', 'a', Symbol()]

        //克隆一个完整对象
        var obj = {
            a: 1,
            b: 2
        }
        var clone1 = {
            __proto__: Object.getPrototypeOf(obj),
            ...obj
        }

        var clone2 = Object.assign(
            Object.create(Object.getPrototypeOf(obj)),
            obj);
        var clone3 = Object.create(
            Object.getPrototypeOf(obj),
            Object.getOwnPropertyDescriptors(obj)
        )
        console.log("complete Object");
        console.log(clone1);
        console.log(clone2);
        console.log(clone3);

        //Object.is()

        const flag1 = Object.is(+0, -0);
        const flag2 = Object.is(NaN, NaN);
        console.log(flag1);
        console.log(flag2);

        //自定义is方法
        Object.defineProperty(Object, 'is', {
            value: function (x, y) {
                if (x === y) {
                    return x !== 0 || 1 / x === 1 / y;
                }
                return x !== x && y !== y;
            },
            writable: true,
            configurable: true,
            enumerable: false
        });
        const flag3 = Object.is(+0, -0);
        const flag4 = Object.is(NaN, NaN);
        console.log(flag3);
        console.log(flag4);

        //Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
        const target = {
            a: 1
        };

        const source1 = {
            b: 2
        };
        const source2 = {
            c: 3
        };

        Object.assign(target, source1, source2);
        //target // {a:1, b:2, c:3}

        const o = Object.getPrototypeOf(true);
        console.log(o);

        // Symbol:新的原始数据类型Symbol，表示独一无二的值,这样就从根本上防止属性名的冲突
        let s = Symbol();
        let s2 = Symbol();
        let a = {
            [s]: 'hello',
            [s2]: 'W'
        }
        a.s2 = 'world'; //s2为属性名，而不是Symbol指向的值
        //console.log(a.s);//undefined
        console.log(a[s]); //正确取值
        console.log(a.s2);
        //console.log(a[s2]);//undefined
        console.log(a['s2']); //world
        console.log(a); //a{s2: "world" , Symbol(): "hello" , Symbol(): "W"}

        let size = Symbol('size');

        class Collection {
            constructor() {
                this[size] = 0;
            }

            add(item) {
                this[this[size]] = item;
                this[size]++;
            }

            static sizeOf(instance) {
                return instance[size];
            }
        }

        let xx = new Collection();
        console.log(Collection.sizeOf(xx)) // 0

        xx.add('foo');
        console.log(Collection.sizeOf(xx)) // 1

        console.log(Object.keys(xx)); // ['0']
        console.log(Object.getOwnPropertyNames(xx)); // ['0']
        console.log(Object.getOwnPropertySymbols(xx)); // [Symbol(size)]

        //Set数据结构
        console.log([...new Set([5, 6, 1, 2, 3, 3, 3])]); //去除重复的数
        console.log([...new Set("aabbcc")].join('')); //去除重复的字符
        console.log(Array.from(new Set([1, 1, 2, 3])));
        //Set认为NaN等于自身，而空对象属于不同的值

        //去除数组重复的值
        function delRepeatValues(arr) {
            let book = [];
            let array = [];
            // for(let i = 0;i<arr.length;i++){
            //     book[arr[i]] = book[arr[i]] || 1;
            //     // if(book[arr[i]] === undefined)
            //     //     book[arr[i]] = 1;
            //     if(book[arr[i]] == 1){
            //         array.push(arr[i]);
            //         book[arr[i]] = -1;
            //     }

            // }

            for (let v of arr) {
                book[v] = book[v] || 1;
                if (book[v] == 1) {
                    array.push(v);
                    book[v] = -1;
                }
            }
            return array;

        }
        let arr = [1, 3, 2, 2, 3, 1];
        let array = delRepeatValues(arr);
        console.log(array);

        console.log(Array.from(new Set(arr)));
        console.log([...new Set(arr)]);

        console.log(+0 === -0); //true
        console.log(NaN === NaN); //false


        //proxy代理的  this问题:目标对象内部的this关键字会指向 Proxy 代理。

        var target2 = {
            m: function () {
                console.log(this == proxy);
            }
        }

        const proxy = new Proxy(target2, {});
        target2.m(); //false
        proxy.m(); //true
        //Reflect的13个静态方法
        // Reflect.get();

        // Reflect.set();
        // Reflect.defineProperty();
        // Reflect.deleteProperty();
        // Reflect.ownKeys();
        // Reflect.isExtensible();
        // Reflect.preventExtensions();
        // Reflect.apply();
        // Reflect.construct();
        // Reflect.getOwnPropertyDescriptor();
        // Reflect.has();
        // Reflect.getPrototypeOf();
        // Reflect.setPrototypeOf();

        // var person = observable({
        //     name:'darcy',
        //     age:22
        // })

        // function print(){
        //     console.log(`${name}`);
        // }
        // observable(print);
        // person.name = 'colines';

        function Obj(value) {
            this.value = value;
            this.next = null;
        }

        Obj.prototype[Symbol.iterator] = function () {
            var iterator = {
                next: next
            };
            var current = this;

            function next() {
                if (current) {
                    var value = current.value;
                    current = current.next;
                    return {
                        value,
                        done: false
                    }
                }
                return {
                    done: true
                };
            }
            return iterator;
        }

        var one = new Obj(1);
        var two = new Obj(2);
        var three = new Obj(3);
        one.next = two;
        two.next = three;
        for (let v of one) {
            console.log(v);

        }

        var g = function* () {
            yield 1;
            yield*[2, 3, 4];
            yield 5;
        }

        var iter = g();
        var iter2 = g();
        // console.log([...iter]);
        console.log(iter); //g {<suspended>}
        for (let v of iter) {
            console.log(v);
        }
        console.log(iter); //g {<closed>}遍历后关闭
        // console.log(iter.next());
        // console.log(iter.next());
        // console.log(iter.next());
        // console.log(iter.next());
        // console.log(iter.next());

        function* gen() {
            this.a = 1;
            yield console.log("ddd");
            yield this.b = 2;
            yield this.c = 3;
        }
        var obj = {};
        var f = gen.call(obj);
        console.log(f.next());
        console.log(f.next());
        console.log(f.next());
        console.log(obj.a);
        console.log(obj.b);
        console.log(obj.c);

        //将生成器函数的原型绑定到this上，生成的遍历器对象拥有gen函数的内部属性
        // var F = gen.call(gen.prototype);
        // console.log(F.next());
        // console.log(F.a);

        // function G() {
        //     return gen.call(gen.prototype);
        // }
        // var f2 = new G();
        // console.log(f2.next());
        // console.log(f2.a);

        function loadUIDataAsynchronously() {
            console.log("get");
        }

        function* loadUI() {
            console.log("start");
            // yield loadUIDataAsynchronously();
            yield console.log("Dd");
            console.log("end");
            return 2;
        }
        var loader = loadUI();
        // 加载UI
        loader.next()

        // 卸载UI
        loader.next()

        function ff(a,b){
            b(a);
            console.log("gg");
        }

        function callback(a){
            console.log(a);
        }

        const thunk = function(fn){
            return function (...args){
                return function (callback){
                    return fn.call(this,...args,callback);
                }
            }
        }

        var T = thunk(ff);
        T(1)(callback);

    </script>
</body>

</html>
<!-- f 0 2 22 then 3 33 then1 4 5   -->